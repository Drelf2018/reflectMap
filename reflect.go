package reflectMap

import (
	"reflect"
	"runtime"
)

// Zero returns a Value representing the zero value for the specified type.
// The result is addressable and settable.
func Zero(typ reflect.Type) reflect.Value {
	return reflect.New(typ).Elem()
}

func FieldsOf(elem reflect.Type) []reflect.StructField {
	if elem.Kind() == reflect.Ptr {
		elem = elem.Elem()
	}
	if elem.Kind() != reflect.Struct {
		return nil
	}
	numFields := elem.NumField()
	fields := make([]reflect.StructField, numFields)
	for i := 0; i < numFields; i++ {
		fields[i] = elem.Field(i)
	}
	return fields
}

func MethodsOf(value reflect.Value) map[reflect.Method]reflect.Value {
	if value.Kind() == reflect.Interface && value.IsNil() {
		return nil
	}
	elem := value.Type()
	r := make(map[reflect.Method]reflect.Value)
	for i := elem.NumMethod() - 1; i >= 0; i-- {
		r[elem.Method(i)] = value.Method(i)
	}
	return r
}

func FunctionsOf(value reflect.Value) map[string]any {
	if value.Kind() == reflect.Interface && value.IsNil() {
		return nil
	}
	elem := value.Type()
	r := make(map[string]any)
	for i := elem.NumMethod() - 1; i >= 0; i-- {
		r[elem.Method(i).Name] = value.Method(i).Interface()
	}
	return r
}

func IsEmbeddedMethod(v reflect.Method) bool {
	f := runtime.FuncForPC(v.Func.Pointer())
	file, _ := f.FileLine(f.Entry())
	return file == "<autogenerated>"
}
